    push CUR
    jmp read_int        ; read an int from up top

    get RG0
    mlt ACC             ; square it
    jof abort_overflow

    push ACC
    push CUR
    jmp print_int       ; print it

    halt

abort_overflow: 
    push error_overflow 
    push CUR 
    jmp print 
    halt 

; functions and stuff: 

; reads a string from up and parses it as an integer
; result in RG0, uses RG1 for temporary storage
read_int:                       ; no args
        get 0
        put RG0                 ; result
    __read_loop: 
        get UP                  ; validate
        jof __read_ret          ; no more input
        jez __read_ret          ; is zero
        sub '0'
        jof __read_ret          ; not valid
        put RG1
        sub 10 
        jof __read_valid        ; overflowing - less or equal than 9 - valid
        jmp __read_ret          ; not valid
    __read_valid:
        get RG0                 ; get result and mult by 10
        mlt 10
        jof abort_overflow      ; mult overflow
        add RG1                 ; value here is between 0x00 and 0x09 inclusiv, add it to result
        jof abort_overflow      ; add overflow
        put RG0                 ; save result
        jmp __read_loop         ; repeat
    __read_ret: 
        pop ACC
        add 3 
        jmp ACC 
 

; 1 arg - number to print
; returns nothing
; uses RG3, RG0 for temporary storage
print_int: 
    pop RG1                     ; return addr 
    pop ACC                     ; number 
__print_int_parse_loop: 
    put RG0                     ; save 
    mod 10                      ; 1 decimal 
    add '0'                     ; to char 
    push ACC                    ; save to the stack 
    jof __print_int_loop        ; print if full 
    get RG0                     ; restore 
    div 10                      ; 1 decimal less 
    jnz __print_int_parse_loop  ; again 
__print_int_loop: 
    pop ACC
    put DWN                     ; rewind and put down 
    jnz __print_int_loop 
__print_int_ret: 
    get RG1
    add 3 
    jmp ACC 

print:
    ; rearrange args to free up all registers
    pop RG3             ; return addr
    ; args
    pop ACC             ; message ptr
    push RG3            ; put ret addr back
__print_loop:
    put RG0             ; save string pointer
    get REF             ; get a byte from the message label, overrides our pointer
    put DWN             ; put down what was here
    jez __print_ret     ; if \0 we end
    jof __print_ret     ; there might be an overflow issue with putting values to slots...
    get RG0             ; restore the pointer
    add 1               ; add 1
    jmp __print_loop    ; back 
__print_ret:
    pop ACC             ; pop return address to acc
    add 3               ; jmp <label> takes 2 bytes
    jmp ACC

; text-like "section"
 
error_overflow: ."Overflow error" 