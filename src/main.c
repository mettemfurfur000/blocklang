#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#include "../include/definitions.h"

bool test_basic_move_down()
{
    instruction code_sample[8] = {};

    code_sample[0] = (instruction){.operation = GET, .target = UP};
    code_sample[1] = (instruction){.operation = JOF, .target = ADJ};
    ((u8 *)code_sample)[2] = 7;
    code_sample[3] = (instruction){.operation = ADD, .target = ADJ};
    ((u8 *)code_sample)[4] = 1;
    code_sample[5] = (instruction){.operation = PUT, .target = ANY};
    code_sample[6] = (instruction){.operation = JMP, .target = NIL};
    code_sample[7] = (instruction){.operation = HALT, .target = NIL};

    const char *source = "get UP\n"
                         "jof end\n"
                         "add 1\n"
                         "put ANY\n"
                         "jmp NIL\n"
                         "end:\n"
                         "halt\n";

    void *bytecode = NULL;
    u8 bytecode_len = 0;

    if (!assemble_program(source, &bytecode, &bytecode_len))
        fprintf(stderr, "Assembly failed\n");
    else
        printf("Assembly succeeded, bytecode length: %d\n", bytecode_len);

    for (u8 i = 0; i < bytecode_len; i++)
        printf("%02X ", ((u8 *)bytecode)[i]);

    // compare sample and generated bytecode

    putchar('\n');

    if (bytecode_len != sizeof(code_sample))
    {
        fprintf(stderr, "Bytecode length mismatch\n");
        return 1;
    }

    for (u8 i = 0; i < bytecode_len; i++)
    {
        if (((u8 *)bytecode)[i] != ((u8 *)code_sample)[i])
        {
            fprintf(stderr, "Bytecode mismatch at index %d: %02X != %02X\n", i, ((u8 *)bytecode)[i],
                    ((u8 *)code_sample)[i]);
        }
    }

    // return 0;

    grid g = initialize_grid(1, 4);

#define LEN 1

    u8 test[LEN] = {10};
    u8 out[LEN] = {};

    attach_input(&g, up, 0, test, sizeof(test));
    attach_output(&g, down, 0, out, sizeof(out));

    // load_program(&g, 0, 0, code_sample, sizeof(code_sample));
    // load_program(&g, 0, 1, code_sample, sizeof(code_sample));
    load_program(&g, 0, 0, bytecode, bytecode_len);
    load_program(&g, 0, 1, bytecode, bytecode_len);
    load_program(&g, 0, 2, bytecode, bytecode_len);
    load_program(&g, 0, 3, bytecode, bytecode_len);

    run_grid(&g, 32);

    free_grid(&g);

    for (u8 i = 0; i < sizeof(test); i++)
        printf("%d -> %d\n", test[i], out[i]);

    return 0;
}

char *read_asm_source_file(const char *filename)
{
    FILE *file = fopen(filename, "r");
    if (!file)
        return NULL;

    fseek(file, 0, SEEK_END);
    long filesize = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *buffer = calloc(filesize + 1, 1);
    if (!buffer)
    {
        fclose(file);
        return NULL;
    }

    fread(buffer, 1, filesize, file);
    buffer[filesize] = '\0';

    fclose(file);
    return buffer;
}

// Sample program: loads blocklang assembly from a file, assembles it, loads it into a grid for each block and runs it
int main(int argc, char *argv[])
{
    if (argc != 4)
    {
        printf("Usage: %s <input file> <width> <height>\n", argv[0]);
        return 1;
    }

    const char *input_file = argv[1];
    int width = atoi(argv[2]);
    int height = atoi(argv[3]);

    char *source = read_asm_source_file(input_file);
    if (!source)
    {
        fprintf(stderr, "Failed to read source file: %s\n", input_file);
        return 1;
    }

    void *bytecode = NULL;
    u8 bytecode_len = 0;

    if (!assemble_program(source, &bytecode, &bytecode_len))
    {
        fprintf(stderr, "Assembly failed\n");
        free(source);
        return 1;
    }

    free(source);

    grid g = initialize_grid(width, height);

    u8 *default_input = calloc(width, 1);
    u8 *default_output = calloc(width, 1);

    for (u8 y = 0; y < g.height; y++)
        for (u8 x = 0; x < g.width; x++)
        {
            attach_input(&g, up, x, default_input, width);
            attach_output(&g, down, x, default_output, width);
            load_program(&g, x, y, bytecode, bytecode_len);
        }

    run_grid(&g, 1000);

    for (u8 i = 0; i < width; i++)
        printf("%d -> %d\n", default_input[i], default_output[i]);

    free(bytecode);
    free_grid(&g);

    return 0;
}